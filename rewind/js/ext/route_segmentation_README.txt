Route Segmentation Algorithm Explanation (updated 26 Sept, 2016)

There are 3 major pieces to the algorithm right now: splitting the data into weeks, identifying Points of Interest (POIs) and unique points, and partitioning and scoring routes to find the best one. For now, a route is defined as being an approximately 10-minute long stretch spent travelling from one POI to another; the "best" route goes through POIs along its route and contains unique points. 

In order to improve the runtime and feasibility of machine learning on datapoints, we split the data into weeks based on the timestamps of the sorted data. We run the route selection algorithm on each separate week of data. 

To identify POIs and unique points, we run two separate iterations of the DBScan (Density-Based clustering) algorithm, implemented in Javascript at https://github.com/uhho/density-clustering. DBScan takes in a neighborhood radius and a neighborhood density and outputs the number of clusters in the dataset: i.e. a high density of points within a certain radius. Anything not placed in a cluster is classified as "noise." For POI identification, we say we want a radius of 0.0005 (degrees) and 10 neighbors within the cluster, with all of the GPS data as our labels. After running, each datapoint is either associated with a certain POI or is "noise," which generally means it's en route from one POI to another. For identifying unique labels, we run a DBScan with radius 0.0005 and require 2 neighbors within the cluster. The intention of this is that routes the user only takes once will be unique, but routes they take many times will not. Admittedly, DBScan may not be the most justifiable clustering method for this, but it seems to perform fairly well. 

Once we've identified POIs, we can identify pieces of the data as routes. We first identify a route from when the user leaves one POI to when they arrive at another and spend at least 30 minutes at that POI, meaning that they stopped and the route has ended. Once we identify this route, we split it up into parts, where each part is a minimum of 10 minutes long (and a maximum of 20 minutes). 

After we have obtained all of the routes, we score each one and identify the one with the highest score. The score is calculated as the ratio of points within POIs plus the ratio of unique points to all points along the route. The justification here is that one kind of "interesting" route would be one where you pass by a lot of interesting points along your way from one place to another; another kind of interesting route would be one you've never taken before. These two combined ratios are weighted equally and each route is scored accordingly. 

(For now, the code contains some lines that were used to visualize things on Google Maps for testing and verification, but once it's merged into the codebase it will interface better with the Rewind app.)
